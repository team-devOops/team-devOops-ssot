# 1. 사가(Saga) 패턴이란?
최근 MSA 환경에서 **분산 트랜잭션을 관리**하기 위한 대표적인 패턴입니다. <br/>
여러 서비스에 걸친 작업을 **하나의 트랜잭션으로 묶는 것이 아닌**, **로컬 트랜잭션**으로 나누고, 실패 시 **보상 트랜잭션**을 실행하여 **일관성을 맞추는** 방식입니다.

## 1-1. 유래
MSA 환경에서 새롭게 나온 패턴은 아닙니다.<br/>
과거 항공 예약이나 은행 이체 등 오랜 시간이 걸리는 **장기 트랜잭션**을 다룰 때, 기존 2PC(2-Phase Commit)로는 **긴 시간 락을 유지**해야 했고, 이는 **성능과 가용성 문제**로 이어졌습니다.

![Pasted image 20250922075549.png](image/Pasted%20image%2020250922075549.png)

그렇기에, 큰 트랜잭션을 작은 트랜잭션으로 쪼개고, 실패 시 보상 작업을 실행하도록 만든 구조가 바로 **사가(Saga) 패턴**입니다.
<br/>
Saga란, 본래 이야기(전설, 서사)라는 뜻을 가지고 있습니다.<br/>
하나의 큰 서사를 이루기 위해, 작은 에피소드로 나누듯이 하나의 큰 트랜잭션을 위해 작은 트랜잭션으로 나누는 것과 같습니다.<br/>

그리하여, 작은 트랜잭션들이 모두 성공적으로 끝나야만 전체 이야기가 완성되게 됩니다.

락을 오래 잡지 않고도 최종적으로 일관성을 보장할 수 있는 방법으로, 오늘날 MSA 분산 트랜잭션 문제를 해결하는 방법으로 재해석되었습니다.

## 1-2. 필요한 이유
모놀리스 형식의 프로젝트에서는 DB를 이용할 때, 한 곳에서 트랜잭션을 묶어 ACID를 보장할 수 있었습니다.<br/>
하지만 MSA 환경의 경우, 각 서비스마다 DB가 분리되어 있기 때문에, 락 장기 유지에 따른 **성능 저하**, 중앙 관리를 하는 조정자 장애 시, 전체 트랜잭션의 정지로 인한 **가용성 문제**가 발생하여 2PC 적용에 한계가 있습니다.

이 때문에 글로벌 트랜잭션을 직접 처리하기 보다는, 각 서비스가 로컬 트랜잭션을 실행하고 실패 시 보상 트랜잭션을 실행할 수 있는 사가 패턴을 활용하게 됩니다.

# 2. 사가패턴의 장단점
## 2-1. 장점
- 글로벌 트랜잭션(2PC) 대비 성능과 확장성 높음
    - 로컬 트랜잭션만 실행 후 커밋하기에 전역 락 유지가 없음
- 부분 실패 복구 가능
    - 2PC는 모든 작업이 성공해야만 전체 성공이고, 하나라도 실패하면 전부 롤백
    - 사가 패턴은 중간에 실패하면 성공했던 서비스들에 대해 보상 트랜잭션을 실행하여 부분적인 실패 복구 가능
- 서비스 간 결합도 감소
    - 서비스-서비스 직접 의존도를 줄이고, 이벤트 브로커나 오케스트레이터라는 중간 계층을 통해 결합도 낮춤
## 2-2. 단점
- 보상 트랜잭션 작성 비용 상승
    - 모든 작업에 보상 트랜잭션 로직이 필요
- 중간 상태 노출
    - 전체 완료 전까지, 사용자와 시스템 모두에게 불완전한 상태가 보여질 수 있음
- 비동기적 최종 일관성 수용 필요
    - 2PC는 하나의 트랜잭션으로 모든 DB 작업이 동시에 커밋되어 즉시 일관성 유지
    - 사가 패턴은 각 서비스가 담당 DB에서만 로컬 트랜잭션 독립적으로 커밋, 실패 시 보상 트랜잭션을 실행하면서 '시간차를 두고' 상태를 맞추게 됨
- 중복 이벤트 처리
    - 재시도 발생 시 이벤트 중복 처리 가능성 존재하여, 멱등성 보장 필수

# 3. 동작 원리
하나의 큰 비즈니스 프로세스를 여러 개의 **로컬 트랜잭션**으로 분할하여 처리합니다.<br/>
각 로컬 트랜잭션은 자기 서비스 DB에 대해서만 원자성 보장하며,<br/>
중간에 실패가 발생하면 이미 완료된 작업에 대해 **보상 트랜잭션**을 실행합니다.

예를 들어, 쇼핑몰에서 물건을 주문하는 기능을 처리하고자 할 때, 아래와 같이 실행되게 됩니다.
- 주문 -> 결제 -> 재고 차감 -> 배송 등록

각 단계는 서비스별로 아래와 같이 처리되게 됩니다.
- 주문 서비스 : 주문 생성
- 결제 서비스 : 결제 승인
- 재고 서비스 : 재고 차감
- 배송 서비스 : 배송 예약

만약 주문, 결제, 재고 차감까지 완료되었으나, 배송 서비스 장애로 배송 등록이 실패하게 된다면,<br/>
앞선 단계에 대해 `재고 복구 -> 결제 취소 -> 주문 취소`와 같은 순서로 보상 트랜잭션이 실행됩니다.

# 4. 사가패턴 구현 방식
## 4-1. 코레오그래피 (Choreography)

![Pasted image 20250922080214.png](image/Pasted%20image%2020250922080214.png)

코레오그래피 방식은, 이벤트 기반(pub/sub)입니다.<br/>
각 서비스는 이벤트를 **구독**한 뒤, **로컬 트랜잭션을 수행**하고, 처리 결과를 **새로운 이벤트로 발행**하게 됩니다.
### 장점
- 별도 중앙 조율자 불필요하여 **구조 단순**
- 서비스가 이벤트만 발행/구독 하기에 **느슨한 결합 유지**

### 단점
- 서비스 간 **이벤트 폭증** 가능
- 전체 프로세스 **흐름 추적의 어려움**
- 이벤트 루프(사이클)나 중복 처리 리스크 존재

### 주요 구현 방식
- Kafka + Spring Cloud Stream: 서비스 간 이벤트 전달
- Outbox 패턴: DB Outbox 테이블에 이벤트 기록 -> CDC(Change Data Capture) -> Kafka 발행
    - 트랜잭션 커밋과 이벤트 발행을 원자적으로 맞추기 위해 사용

## 4-2. 오케스트레이션 (Orchestration)
![Pasted image 20250922080355.png](image/Pasted%20image%2020250922080355.png)

오케스트레이션 방식에서는 중앙의 **사가 오케스트레이터**가 각 서비스에게 **트랜잭션 실행 지시**를 합니다.<br/>
실패가 발생했을 때도, 사가 오케스트레이터가 보상 트랜잭션 실행을 지시하여 전체 흐름을 관리하는 역할을 하게 됩니다.
### 장점
- 흐름 제어가 명확하여 **시각적으로 이해가 쉬움**
- 복잡한 시나리오나 조건 분기 관리가 용이
### 단점
- 오케스트레이터 **자체 복잡도 증가**
- 오케스트레이터가 **단일 장애 지점(SPOF)** 가 될 수 있음

### 주요 프레임워크
- Camunda: BPMN 기반 워크플로우 엔진, 시각적 모델링 가능
- Temporal: 코드로 워크플로우 정의, 재시도/보상 로직을 안전하게 관리
- Axon Framework: CQRS + 이벤트 소싱 지원, 사가 관리 기능 내장

---
# 느낀점
아직 MSA 환경에서 직접 개발해 본 경험은 없지만, 서비스 간 여러 트랜잭션을 어떻게 관리하는지에 대한 궁금증은 늘 존재했었습니다.<br/>
이번 학습을 통해 사가 패턴의 개념과 왜 필요한지를 다시 한번 알게 되었고, 개념에 대해서는 이해할 수 있었습니다. 다만 실제 코드 수준에서 어떻게 구현되는지가 추가적으로 궁금해지는 것 같습니다.

