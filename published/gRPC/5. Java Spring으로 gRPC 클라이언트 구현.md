# **🎯 5일차 학습 목표: gRPC 클라이언트 구현**
1. **Stub 사용법**
    - BlockingStub (동기 호출)
    - FutureStub (비동기, Future 기반)
    - AsyncStub (콜백 기반 비동기 호출)
2. **클라이언트 구성하기**
3. **각 통신 패턴 호출하기**
    - Unary RPC 호출 → 응답 1개 받기
    - Server Streaming 호출 → 스트림 순회하면서 응답 여러 개 받기
    - Client Streaming 호출 → 요청 여러 개 보내고 응답 1개 받기
    - Bidirectional Streaming 호출 → 요청과 응답을 동시에 처리

---
# 1. Stub 사용법
Stub이란, 클라이언트에서 서버 메서드를 호출할 수 있도록 자동 생성된 프록시 객체를 의미합니다.
즉, 클라이언트 입장에서는 원격에 있는 gRPC 서버 메서드를 **로컬 메서드처럼 호출**할 수 있도록 합니다.

## 1-1. Stub의 역할
1. 직렬화/역직렬화 자동 처리
    - 클라이언트 -> 서버로 보낼 요청 객체(ProtoBuf 메세지)를 바이너리로 직렬화
    - 서버에서 내려온 응답을 ProtoBuf -> Java 객체로 역직렬화
2. 네트워크 통신 추상화
    - HTTP/2 기반으로 gRPC 요청을 전송하고 응답받는 과정을 숨겨줌
3. 호출 방식 제공
    - 여러 가지 (동기, 비동기, 퓨처) 기반 호출 지원

## 1-2. Stub의 종류
#### 1) BlockingStub (동기)
메서드 호출이 끝날 때까지 **현재 스레드가 대기**합니다.
단순하지만, 많은 요청을 동시에 처리하는 환경에서는 부적합합니다.

#### 2) AsyncStub (비동기)
요청을 보내고 `StreamObserver`로 응답을 비동기로 받습니다.
서버 스트리밍, 클라이언트 스트리밍, 양방향 스트리밍에 적합합니다.

#### 3) FutureStub (퓨처)
Google Guava의 ListenableFuture 기반 비동기 호출을 하게 됩니다.
콜백과 체이닝 처리에 유용합니다.

# 2. 클라이언트 구성하기
## 2-1. dependency 추가
##### build.gradle.kts
```kts
import com.google.protobuf.gradle.*  
  
plugins {  
    ...
    id("com.google.protobuf") version "0.9.4"  
}    
  
dependencies {  
    
    // gRPC  
    implementation("io.grpc:grpc-protobuf:1.62.2")  
    implementation("io.grpc:grpc-stub:1.62.2")  
    implementation("io.grpc:grpc-netty-shaded:1.62.2")  
    implementation("net.devh:grpc-client-spring-boot-starter:3.0.0.RELEASE")  
  
    compileOnly("jakarta.annotation:jakarta.annotation-api:1.3.2")   
}  
  
protobuf {  
    protoc {  
       artifact = "com.google.protobuf:protoc:3.25.2"  
    }  
    plugins {  
       id("grpc") {  
          artifact = "io.grpc:protoc-gen-grpc-java:1.62.2"  
       }  
    }    generateProtoTasks {  
       all().forEach { task ->  
          task.plugins {  
			    id("grpc")  
			} 
       }    
   }
}  
...
```
- import com.google.protobuf.gradle.*
    - `probobuf { ... }` DSL을 사용하기 위해 import 추가
- plugins
    - id("com.google.protobuf") version "0.9.4"
        - Google에서 제공하는 **protobuf-gradle-plugin** 적용
        - `.proto` 파일을 자동으로 찾아서 protoc 실행 -> Java 소스 코드 생성
- dependencies
    - grpc-netty-shaded: gRPC 서버/클라이언트를 실행하기 위한 Netty 기반 전송 계층 라이브러리
    - grpc-protobuf: ProtoBuf 메시지를 gRPC에서 쓰기 위한 직렬화 지원
    - grpc-stub: Stub 클래스(gRPC 클라이언트 프록시 객체)를 제공
- protobuf
    - protoc: proto 컴파일러(Protocol Buffers Compiler) 버전 지정, 3.25.2 버전 사용
    - plugins: 추가 코드 생성 플러그인 지정
        - grpc: gRPC 서비스용 Java 코드 생성기 (protoc-gen-grpc-java) -> ImplBase, Stub 등 생성
    - generateProtoTasks
        - `.proto` 파일 빌드 시 적용할 작업 정의
        - 모든 proto 파일에 대해 gRPC 플러그인을 적용(`task.plugins { id("grpc") }`)
        - 이로인해 메시지 클래스 + gRPC 서버/클라이언트 Stub 코드 자동 생성

gradle 의존 받고, `generateProto` task를 실행 시키면, 아래와 같이 코드가 자동 생성됩니다.
![[Pasted image 20250926130913.png]]

## 2-2. gRPC 설정 추가
##### 기본 설정 추가
```yml
// application.yml
grpc:  
  client:  
    hello:  
      address: "static://127.0.0.1:9097"  
      negotiationType: PLAINTEXT
```
- `grpc.client.hello`
    - hello라는 이름의 클라이언트를 정의
    - 이 이름은 `@GrpcClient("hello")`형식으로 주입할 때 매핑 됨
- address
    - gRPC 서버의 위치
        - static://host:port 형식, 단일 서버 주소
        - dns://... 형식, DNS 기반 서버 주소
- negotiationType
    - gRPC의 채널 보안 모드
    - PLAINTEXT : TLS 없이 평문, 로컬 개발용
    - TLS : TLS 사용, 운영 환경에서 권장

##### 연결 관리
```
grpc:  
  client:  
    hello:  
      ...
      enable-keep-alive: true  
      keep-alive-time: 60s           # Ping 주기  
      keep-alive-timeout: 20s        # Ping 응답 없을 때 
      timeout      keep-alive-without-calls: true  # RPC 호출 없을 때도 Ping 유지
```

## 2-3. 서비스 구현
```java
@Service  
public class HelloService {  
  
    @GrpcClient("hello")  
    private HelloServiceGrpc.HelloServiceBlockingStub blockingStub;  
  
    public String call(String name) {  
        final HelloResponse response = blockingStub.sayHello(  
            HelloRequest.newBuilder()
	            .setName(name)
	            .build()  
        );  
        return response.getMessage();  
    }  
}
```
- `@GrpcClient("hello")`
    - `application.yml`에서 설정한 `grpc.client.hello` 설정을 찾아 채널을 만듭니다.
    - 그 채널을 통해 사용할 수 있는 Stub(BlockingStub)을 주입합니다.
- `private HelloServiceGrpc.HelloServiceBlockingStub blockingStub;`
    - `.proto`파일에서 `HelloService` 정의를 바탕으로 자동 생성된 클라이언트 Stub 클래스입니다.
    - BlockingStub은 동기 방식으로 RPC 호출합니다.
        - 메서드가 끝날 때까지 현재 쓰레드가 블로킹됩니다.

### 1) 비동기 Stub 설정 법
```java
@GrpcClient("hello")  
private HelloServiceGrpc.HelloServiceStub stub;  
```
- StreamObserver 콜백을 통해 응답을 받습니다.
- Server Streaming, Client Streaming

### 2) Future Stub 설정 법
```java
@GrpcClient("hello")  
private HelloServiceGrpc.HelloServiceFutureStub futureStub;
```
- Guava의 ListenableFuture를 반환합니다.
- 비동기 호출은 하지만 결과를 `Future.get()` 같은 방식으로 제어합니다.
- 단일 요청/응답(Unary RPC)에 적합합니다.
- 스트리밍 방식에는 부적합

# 3. 각 통신 패턴 호출하기
## 3-1. Unary RPC 호출 (요청 1 <-> 응답 1)
단순 동기 호출이라 코드가 가장 간단합니다.
```java
public String callUnary(final String name) {  
    final HelloRequest request = HelloRequest.newBuilder().setName(name).build();  
  
    final HelloResponse response = blockingStub  
        .withDeadlineAfter(1, TimeUnit.SECONDS)  
        .sayHello(request);  
      
    return response.getMessage();  
}
```
시간이 오래 걸리는 작업의 경우, `withDeadlineAfter`로 타임아웃 제어가 가능합니다.
##### 타임아웃 발생 시
아래와 같은 Exception이 발생됩니다.
```
io.grpc.StatusRuntimeException: DEADLINE_EXCEEDED: deadline exceeded after 0.884766750s. Name resolution delay 0.000000000 seconds. [closed=[], open=[[buffered_nanos=10605583, remote_addr=/127.0.0.1:9097]]]
```
##### 응답
```
반갑습니다~ zinzo님
```
## 3-2. Server Streaming 호출 (요청 1 <-> 응답 N)
```java
public String callClientStreaming(String... names) throws InterruptedException {  
    CountDownLatch done = new CountDownLatch(1);  
    final StringBuilder result = new StringBuilder();  
  
    StreamObserver<HelloResponse> respObserver = new StreamObserver<>() {  
        @Override   
		public void onNext(HelloResponse value) {  
            result.append(value.getMessage());  
        }  
        @Override   
		public void onError(Throwable t) {  
            t.printStackTrace();  
            done.countDown();  
        }  
        @Override   
		public void onCompleted() {  
            System.out.println("client-stream completed");  
            done.countDown();  
        }  
    };  
  
    // 요청 스트림을 위한 Observer 획득  
    StreamObserver<HelloRequest> reqObserver = stub.uploadGreetings(respObserver);  
  
    // N개의 요청 전송  
    for (String n : names) {  
        reqObserver.onNext(HelloRequest.newBuilder().setName(n).build());  
    }  
    // EOF(입력 종료) 알림  
    reqObserver.onCompleted();  
  
    // 최종 응답 1개 도착까지 대기  
    done.await(5, TimeUnit.SECONDS);  
    return result.toString();  
}
```
응답이 여러개가 오기 때문에, `onNext()`가 여러번 호출 됩니다.
클라이언트에서는 스트림 종료를 `onCompleted()`로 감지하게 됩니다.
##### 응답
```
chunk: [chunk 1] 안녕하세요, zinzo님
chunk: [chunk 2] 안녕하세요, zinzo님
chunk: [chunk 3] 안녕하세요, zinzo님
server-stream completed
```

## 3-3. Client Streaming 호출 (요청 N <-> 응답 1)
```java
public String callClientStreaming(String... names) throws InterruptedException {  
    CountDownLatch done = new CountDownLatch(1);  
    StringBuilder result = new StringBuilder();  
  
    StreamObserver<HelloResponse> responseObserver = new StreamObserver<>() {  
        @Override  
        public void onNext(HelloResponse value) { // 최종 1회  
            result.append(value.getMessage());  
        }  
        @Override  
        public void onError(Throwable t) {  
            Status status = Status.fromThrowable(t);  
            System.err.println("[client-stream][error] " + status.getCode() + " - " + s.getDescription());  
            done.countDown();  
        }  
        @Override  
        public void onCompleted() { done.countDown(); }  
    };  
  
    // 필요 시 데드라인: asyncStub = asyncStub.withDeadlineAfter(10, TimeUnit.SECONDS);  
    StreamObserver<HelloRequest> requestObserver = stub.uploadGreetings(responseObserver);  
  
    try {  
        for (String it : names) {  
            requestObserver.onNext(HelloRequest.newBuilder()
	            .setName(it)
	            .build()
			);  
        }  
        requestObserver.onCompleted(); // EOF 알림 → 서버가 최종 응답 생성  
        boolean finished = done.await(15, TimeUnit.SECONDS);  
        return finished ? result.toString() : "TIMEOUT";  
    } catch (Throwable t) {  
        requestObserver.onError(t); // 전송 중 오류 시 스트림에 에러 전달  
        throw t;  
    }  
}
```
- `StreamObserver<HelloResponse> responseObserver = new StreamObserver<>() {...}`
    - 서버에 응답을 처리하는 콜백 리스너
    - `onNext`
        - 서버가 응답을 내려줄 떄 호출
        - Client Streaming에서는 응답이 한 번만 오므로 여기서 최종 메세지 저장
    - `onError`
        - 서버 쪽에서 에러 발생 시 호출
        - gRPC의 Status 객체로 변환해 로그 출력
    - `onCompleted`
        - 서버 응답 스트림 종료 시 호출
        - done.countDown()으로 대기 중인 스레드를 깨움
- `StreamObserver<HelloRequest> reqObserver = stub.uploadGreetings(responseObserver);`
    - 서버에서 요청을 보낼 수 있는 스트림 핸들러를 흭득
    - `stub.uploadGreetings(...)` : 서버의 RPC 호출
    - `responseObserver`는 서버 응답 처리 콜백
- `for (String it : names) { ... }`
    - `onNext()`를 호출 함으로써 요청 N개가 발생하는 부분
- `reqObserver.onCompleted();`
    - 모든 요청 전송이 끝났음을 서버에 알림
    - 해당 신호를 받은 서버에서는 최종 응답 한개를 만들어 `responseObserver.onNext()`로 전달
##### 응답
```json
{
  "message": "안녕하세요, a님, 안녕하세요, b님"
}
```

## 3-4. Bidirectional Streaming 호출 (요청 N <-> 응답 N)
```java
public void callBidiStreaming(String... names) throws InterruptedException {  
    CountDownLatch done = new CountDownLatch(1);  
  
    // 서버 응답 처리 리스너  
    StreamObserver<HelloResponse> responseObserver = new StreamObserver<>() {  
        @Override  
        public void onNext(HelloResponse value) {  
            System.out.println("[bidi][resp] " + value.getMessage());  
        }  
        @Override  
        public void onError(Throwable t) {  
            var st = io.grpc.Status.fromThrowable(t);  
            System.err.println("[bidi][error] " + st.getCode() + " - " + st.getDescription());  
            done.countDown();  
        }  
        @Override  
        public void onCompleted() {  
            System.out.println("[bidi] stream completed");  
            done.countDown();  
        }  
    };  
  
    // 요청 스트림 Observer 획득 (요청 보낼 통로)  
    StreamObserver<HelloRequest> reqObserver = stub.chat(responseObserver);  
  
    try {  
        for (String n : names) {  
            System.out.println("[bidi][send] " + n);  
            reqObserver.onNext(HelloRequest.newBuilder().setName(n).build());  
            Thread.sleep(1000); // 일부러 지연 → 서버 응답과 교차 가능  
        }  
        reqObserver.onCompleted(); // 요청 스트림 종료 알림  
        done.await(10, TimeUnit.SECONDS); // 응답 완료까지 대기  
    } catch (Throwable t) {  
        reqObserver.onError(t);  
        throw t;  
    }  
}
```

##### 응답
```
[bidi][send] a
[bidi][resp] [bidi] 안녕하세요, a님
[bidi][send] b
[bidi][resp] [bidi] 안녕하세요, b님
[bidi][send] c
[bidi][resp] [bidi] 안녕하세요, c님
[bidi] stream completed
```

---
# 느낀점

단순 예제 코드를 작성하면서, 요청 N이나 응답 N의 경우(Bidirectional Streaming)는 언제 써야 할지 잘 감이 안 오는 것 같습니다.
다만, 클라이언트 입장에서 단순 함수를 호출하는 방식만으로 실행이 되는 걸 직접 실습을 해 보니 너무 신기하단 생각이 들었습니다.

Future Stub 같은 경우에도 어떻게 활용하면 좋을지 아직은 잘 모르겠다만 ^^;
이러한 기본이 결국 나중에 필요할 때 기반이 된다는 것을 잊지않고...

바로 다음은 에러 처리와, 메타데이터 요청 보내는 방식 등에 대해서 실습해 보고자 합니다.