# **🎯 4일차 학습 목표**
1. **Metadata(메타데이터)**
    - REST의 HTTP Header처럼 gRPC 요청/응답에 부가 정보 전달하기
    - 예: 인증 토큰(JWT), 트레이싱 ID, 사용자 ID
2. **Deadline, Timeout, 취소(Cancellation)**
    - 클라이언트가 RPC 호출 시 “언제까지 기다릴지” 설정하는 방법
    - 서버는 이 시간 초과를 감지하고 작업 중단 가능
    - 클라이언트가 요청을 취소했을 때 서버가 감지하는 방법
    - 긴 처리 작업 중 자원 낭비 방지

---
# 1. Metadata(메타데이터)
메타데이터란, gRPC에서 **HTTP Header**와 같은 역할을 합니다.
클라이언트와 서버 간 요청과 응답에 추가적인 정보(key - value)를 담아 전달할 수 있습니다.

- 사용 예
    - 인증 토큰 - (Authorization: Bearer …)
    - 트레이싱 ID (X-Request-ID)
    - 다국어/Locale

## 1-2. 메타데이터 종류
### 헤더
- 요청 헤더
    - 클라이언트 -> 서버 전송할 때 사용
    - RPC 호출 시작 시 전송
- 응답 헤더
    - 서버 -> 클라이언트 전송 시 사용
    - 응답 본문 (message)가 내려가기 전에 전송되는 메타데이터
### 트레일러
- 응답 마지막에 전송되는 메타데이터
- 주로 에러 정보, 상태 코드, 추가 디버깅 데이터에 사용

## 1-3. 메타데이터 키 이름 규칙
1. 키 이름은 **소문자**일 것
    - ASCII 소문자(a-z), 숫자(0-9), `-`(하이픈) 사용 권장
    - 대문자(ex, Authorization), 공백 사용 금지
2. 예약 접두사 금지
    - `:`(콜론)으로 시작하는 이름은 HTTP/2 예약 헤더, 커스텀 메타데이터로 사용 금지
3. 바이너리 값은 반드시 `-bin` 접미사 사용
    - `-bin` (예, authorization-bin) 같은 키만 `BINARY_BYTE_MARSHALLER` 사용 가능
    - 클라이언트에서 전송할 때는 Base64로 인코딩된 값이 들어가야 함
    - 서버에서 `byte[]`로 꺼낼 수 있음
4. 길이 제한
    - 키 이름 : 1~127바이트 (HTTP/2 헤더 제한)
    - 값 : 0~8KB 권장 (HTTP/2 프레임 크기 제한 내)
5. 중복 가능
    - 같은 키 이름으로 여러 값 보내기 가능
        - 서에서 headers.getAll(key) 형식으로 조회

## 1-4. 서버에서 메타데이터 처리하기
gRPC 인터셉터를 통해 메타데이터를 처리할 수 있습니다.

인터셉터 등록을 해주려면 `@GrpcGlobalServerInterceptor` 어노테이션을 사용해 쉽게 처리해 줄 수 있습니다.
인터셉터가 여러 개 있다면, 순서 보장이 되지 않기 때문에 제어하기 위해서는 `@Order` 를 통해 지정 가능합니다.

```java
@Order(1)  
@GrpcGlobalServerInterceptor  
public class HelloInterceptor implements ServerInterceptor {  
  
    private static final Metadata.Key<String> METADATA_KEY =  
        Metadata.Key.of("authorization", Metadata.ASCII_STRING_MARSHALLER);  
  
    private static final Set<String> PASS_PATH = Set.of(  
        "kr.co.grpc.hello.UnaryService/callUnary"  
    );  
  
    @Override  
    public <ReqT, RespT> Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call, Metadata headers,  
        ServerCallHandler<ReqT, RespT> next) {  
  
        final String path = call.getMethodDescriptor().getFullMethodName();  
          
        if (PASS_PATH.contains(path)) {  
            return next.startCall(call, headers);  
        }  
        final String token = headers.get(METADATA_KEY);  
          
        if (!StringUtils.hasText(token)) {  
            call.close(Status.UNAUTHENTICATED.withDescription("토큰이 유효하지 않습니다."), new Metadata());  
            return new ServerCall.Listener<>() {};  
        }  
  
        return next.startCall(call, headers);  
    }  
}
```
- `Metadata.Key<String> METADATA_KEY`
    - gPRC 메타 데이터에 접근할 때 사용하는 키 객체
    - "authorization" 이라는 헤더 이름을 ASCII 문자열 마샬러를 이용해 읽겠다는 것을 의미
- `Set<String> PASS_PATH`
    - 특정 gRPC 메서드 이름을 지정
    - 해당 메서드는 검증하지 않고 무조건 패스하기 위해구성
    - 포맷은, `패키지.서비스명/메서드명` 형식으로, gRPC 내부에서 쓰는 canonical name
- `interceptCall`
    - ServerInterceptor 인터페이스의 핵심 메서드
    - 클라이언트 -> 서버 RPC 호출이 들어올 때마다 실행됨
    - 파라미터 의미
        - ServerCall<ReqT, RespT> call
            - 현 요청의 전체 핸들러
        - Metadata headers
            - 클이언트가 보낸 요청 헤더를 담은 객체
        - ServerCallHandler<ReqT, RespT> next
            - 체인의 다음 핸들러 (인터셉터 혹은 서비스 구현체가 될 수 있음)
- call.getMethodDescriptor().getFullMethodName()
    - 현재 호출된 gRPC 메서드 풀 네임을 가져옴
- next.startCall(call, headers)
    - 체인의 다음 단계 (인터셉터 혹은 서비스 구현체)로 RPC 처리를 넘김
    - Spring MVC의 `filterChain.doFilter()`와 비슷함
    - 해당 부분을 호출하지 않으면, 실제 서비스 코드까지 도달하지 않음
- headers.get(METADATA_KEY)
    - 클라이언트가 보낸 요청 헤더에서 `authorization` 키를 꺼냄
    - 없으면 null, 있으면 문자열로 반환
- call.close()
    - 현재 RPC 요청을 에러로 즉시 종료
    - 추가 트레일러가 필요하다면, 파라미터 마지막에 `Metadata`에 넣어 전달
- new ServerCall.Listener<>() {}
    - 빈 리스너를 반환하여 더 이상 이벤트 처리하지 않음을 의미
    - 해당 RPC 호출은 해당 부분에서 차단되고, 서비스 구현체로 전달되지 않음
- next.startCall(call, headers)
    - 토큰이 정상적으로 존재하면 체인을 이어서 다음으로 넘김

## 1-5. 요청 헤더 서비스에서 활용하기
서비스에서 메타데이터를 사용하기 위해서는 `Context` 를 활용할 수 있습니다.

### 1) 전역 키 클래스 생성
```java
public class GrpcContextKeys {  
  
    public static final Context.Key<String> AUTHORIZATION = Context.key("authorization");  
  
    public GrpcContextKeys() {  
    }
}
```
- gRPC 컨텍스트에서 꺼내 쓸 수 있는 키들을 모아 둔 전역 키 클래스입니다.

### 2) 인터셉터에서 헤더 추출 후, Context에 저장
```java
@Order(1)  
@GrpcGlobalServerInterceptor  
public class HelloInterceptor implements ServerInterceptor {  
  
    private static final Metadata.Key<String> METADATA_KEY =  
        Metadata.Key.of("authorization", Metadata.ASCII_STRING_MARSHALLER);  
  
    @Override  
    public <ReqT, RespT> Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call, Metadata headers,  
        ServerCallHandler<ReqT, RespT> next) {  
  
        final Context context = Context.current()  
            .withValue(GrpcContextKeys.AUTHORIZATION, headers.get(METADATA_KEY));  
  
        return Contexts.interceptCall(context, call, headers, next);  
    }  
}
```
- `Context.current()`
    - 현재 요청의 gRPC 컨텍스트를 가져옴
    - ThreadLocal과 비슷하지만 gRPC 내부적으로 관리됨
- `withValue(GrpcContextKeys.AUTHORIZATION, headers.get(METADATA_KEY))`
    - 새로운 파생 Context 생성
    - 원본 Context는 그대로 두고, 새로운 Context에 추가 값만 붙여서 반환
- `Contexts.interceptCall(context, call, headers, next)`
    - 새 Context를 전체 체인에 전파하여 다음 단계로 넘어감

### 3) 서비스에서 컨텍스트 호출
```java
@Override  
public void sayHello(HelloRequest request, StreamObserver<HelloResponse> responseObserver) {  
    final String auth = GrpcContextKeys.AUTHORIZATION.get();  
  
    final String message = "반갑습니다~ " + auth + "님";  
  
    final HelloResponse response = HelloResponse.newBuilder()  
        .setMessage(message)  
        .build();  
  
    responseObserver.onNext(response);  // 응답 전달  
    responseObserver.onCompleted();     // 스트림 종료  
}
```
- `GrpcContextKeys.AUTHORIZATION.get()`
    - 현 요청의 컨텍스트에서 `authorization` 키에 저장된 값 호출
### 3) 요청
```shell
grpcurl -plaintext -H "authorization: zinzo" localhost:9097 HelloService/SayHello
```
- `-H` 를 이용해 요청
##### 응답
```
{
  "message": "반갑습니다~ zinzo님"
}
```

## 1-6. 응답 헤더 클라이언트에 내려주기
### 1) 응답 헤더 내려주기 위한 인터셉터 생성
```java
@Order  
@GrpcGlobalServerInterceptor  
public class ResponseHeaderInterceptor implements ServerInterceptor {  
  
    private static final Metadata.Key<String> SERVER_HEADER =  
        Metadata.Key.of("x-server", Metadata.ASCII_STRING_MARSHALLER);  
  
    @Override  
    public <ReqT, RespT> Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call, Metadata headers,  
        ServerCallHandler<ReqT, RespT> next) {  
  
        ServerCall<ReqT, RespT> forwardingCall =  
            new ForwardingServerCall.SimpleForwardingServerCall<>(call) {  
                @Override  
                public void sendHeaders(Metadata responseHeaders) {  
                    responseHeaders.put(SERVER_HEADER, "grpc-spring-boot");  
                    super.sendHeaders(responseHeaders); // 실제 전송  
                }  
            };  
  
        return next.startCall(forwardingCall, headers);  
    }  
}
```
- `ForwardingServerCall`
    - ServerCall을 감싸서 동작을 가로채고, 일부만 바꾼 뒤 원래 동작을 호출할 수 있는데코레이터 패턴의 클래스
- `sendHeaders()`
    - 응답을 보낼 때 가장 먼저 내려가는 헤더 전송 메서드

### 2. 요청
```shell
grpcurl -v -plaintext -H "authorization: zinzo" localhost:9097 HelloService/SayHello
```
- `-v` 옵션을 통해 헤더 정보도 함께 조회
##### 응답
```
Resolved method descriptor:
rpc SayHello ( .HelloRequest ) returns ( .HelloResponse );

Request metadata to send:
authorization: zinzo

Response headers received:
content-type: application/grpc
grpc-accept-encoding: gzip
x-server: grpc-spring-boot // <- 확인 가능

Response contents:
{
  "message": "반갑습니다~ zinzo님"
}

Response trailers received:
(empty)
Sent 0 requests and received 1 response
```

## 1-7. 트레일러 전송 방법
트레일러란 응답이 끝날 때, 마지막에 오는 메타데이터를 의미하는데, 주로 에러 코드나 추가 정보를 담을 때 사용하게 됩니다.

트레일러가 비어 있을 경우 아래와 같이 응답이 내려오게 됩니다.
```
Response trailers received:
(empty)
```

### 1) 서비스에서 트레일러 응답주기
```java
@Override  
public void sayHello(HelloRequest request, StreamObserver<HelloResponse> responseObserver) {  
    if (!StringUtils.hasText(request.getName())) {  
        Metadata trailers = new Metadata();  
        Metadata.Key<String> ERROR_CODE =  
            Metadata.Key.of("x-error-code", Metadata.ASCII_STRING_MARSHALLER);  
        trailers.put(ERROR_CODE, "VAL_001");  
  
        responseObserver.onError(  
            Status.INVALID_ARGUMENT  
                .withDescription("이름은 필수입니다.")  
                .asRuntimeException(trailers) // <- 여기서 트레일러 포함  
        );  
        return;  
    }
    ...
```

### 2) 요청
```
grpcurl -v -plaintext localhost:9097 HelloService/SayHello
```
##### 응답
```
Resolved method descriptor:
rpc SayHello ( .HelloRequest ) returns ( .HelloResponse );

Request metadata to send:
(empty)

Response headers received:
(empty)

Response trailers received:
content-type: application/grpc
x-error-code: VAL_001 // <- 확인 가능
Sent 0 requests and received 0 responses
ERROR:
  Code: InvalidArgument
  Message: 이름은 필수입니다.
```
Response trailers received 항목에 커스텀 메타데이터를 설정한 것이 보입니다.

# 2. Deadline, Timeout
HTTP/2를 이용해서 gRPC가 동작하지만, HTTP의 Timeout과 달리 Deadline을 사용하고 있습니다.
클라이언트가 "이 RPC 요청은 언제까지 끝나야 함"이라고 마감 시각을 지정하고, 그 시간을 넘길 경우 서버/클라이언트 모두 요청을 **자동 취소**합니다.

- Timeout : 상대적인 시간
    - ex, timeout = 5 (5초 내로 요청을 처리할 것)
- Deadline : 절대적인 시간
    - ex, deadline = 2025-05-05T23:00:00 (25년 5월 5일 23시까지 요청을 처리할 것)

gRPC는 내부적으로 timeout을 deadline으로 변환해 동작하는 방식입니다.

## 2-1. Deadline을 사용하는 이유
HTTP의 timeout은 **클라이언트 단에서만 동작**합니다.
gRPC의 deadline은 클라이언트와 서버 모두가 알 수 있고, 중간 프록시도 같이 deadline을 읽을 수 있습니다.
이 덕분에, 불필요한 리소스 소비를 줄이고, 중간 계층도 해당 요청이 타임아웃임을 인지하고 빠르게 끊어줄 수 있습니다.

## 2-2. 동작 방식
- 클라이언트에서 서버에 요청할 때, 데드라인 시간을 함께 서정
- gRPC 프레임에는 `grpc-timeout` 메타 데이터가 포함됨
- 서버에서는 Context를 통해 취소 신호 확인 가능
- 지정된 Deadline 시간이 지나면 서버는 작업 중이더라도, **DeadlineExceeded** 혹은 **Cancelled**상태로 종료

## 2-3. Deadline 응답 확인하기
### 1) 서버에서 오랜 시간 걸리는 기능 구현
```java
@Override  
public void sayHello(HelloRequest request, StreamObserver<HelloResponse> responseObserver) {  
    try {  
        Thread.sleep(30000);  
    } catch (InterruptedException e) {  
        throw new RuntimeException(e);  
    }
    ...
```

### 2) Deadline 설정하고 요청
```shell
grpcurl -plaintext \
  -max-time 1 \
  -d '{"name":"zinzo"}' \
  localhost:9097 HelloService/SayHello
```
##### 응답
```
ERROR:
  Code: DeadlineExceeded
  Message: context deadline exceeded
```

- DeadlineExceeded : 클라이언트 요청의 deadline 초과했을 때
- Cancelled : 클라이언트가 직접 취소했을 때

## 2-4. 남은 Deadline 시간 확인하기
Deadline 시간을 확인함으로써, 오래 걸리는 로직에서 중간중간 체크하여 빠르게 중단하는 방식으로 사용 가능합니다.
그렇지 않으면, deadline은 초과했음에도 불구하고 서버 스레드는 계속 낭비되는 문제가 발생하게 됩니다.
```java
@Override  
public void sayHello(HelloRequest request, StreamObserver<HelloResponse> responseObserver) {  
    Deadline deadline = Context.current().getDeadline();  
    if (deadline != null) {  
        System.out.println("요청 마감 시각: " + deadline);  
        System.out.println("남은 시간(ms): " + deadline.timeRemaining(TimeUnit.MILLISECONDS));  
    }  
  
    try {  
        Thread.sleep(30000);  
    } catch (InterruptedException e) {  
        throw new RuntimeException(e);  
    }  
  
    if (Context.current().isCancelled()) {  
        System.out.println("⚠️ 클라이언트가 취소했거나, 데드라인이 지남");  
    }
```
- getDeadline() : 요청이 언제까지 유효한지 확인 가능
- isCanclled() : 취소/초과 여부 확인 가능
##### 요청
```shell
grpcurl -plaintext \
  -max-time 1 \
  -d '{"name":"zinzo"}' \
  localhost:9097 HelloService/SayHello
```
##### 응답
```
ERROR:
  Code: DeadlineExceeded
  Message: context deadline exceeded
```
##### 콘솔
```
요청 마감 시각: 0.774270250s from now
남은 시간(ms): 768
⚠️ 클라이언트가 취소했거나, 데드라인이 지남
```

---
# 느낀점
헤더를 무조건 인터셉터에서 처리해야 된다는 게 낯설고 불편하다는 생각이 들었던 것 같습니다.
또한 메타데이터를 받기 위해서는 파라미터를 통해 받는 것이 아닌 컨텍스트로 코드 블록 내에서 받는 점 역시 괜찮나 싶었습니다.

아무래도 항상 HTTP 프로토콜을 이용한 개발만 해오다가 새로운 프로토콜 개발을 하려다 보니 낯선 것이 상당히 많은 것 같은데요.

그중에서도 신기했던 점으로는, 데드라인이 서버 쪽에서도 인지가 가능하다는 것이었습니다.
하지만 그만큼 신경 써서 개발할게 많아지겠다는 부담으로도 다가오는 것 같습니다.

다음에는 미루고 미뤘던 클라이언트 서버를 직접 구현해 보도록 하겠습니다.

